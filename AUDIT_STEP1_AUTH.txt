============================================================
SENDMAX - LECTURA ARCHIVOS AUTH + DIAGNOSTICS
Fecha: 02/19/2026 19:00:32
============================================================


### ARCHIVO: backoffice_api/app/auth.py ###
"""Autenticacion para backoffice: JWT (principal) + API KEY (legacy/fallback)"""

import os
from fastapi import Depends, HTTPException, Security, status, Request
from fastapi.security import APIKeyHeader, OAuth2PasswordBearer
from jose import JWTError, jwt
from dotenv import load_dotenv

load_dotenv()

EXPECTED_API_KEY = os.getenv("BACKOFFICE_API_KEY")
SECRET_KEY = os.getenv("SECRET_KEY", "supersecretkey_cambiar_en_prod")
ALGORITHM = os.getenv("ALGORITHM", "HS256")

api_key_header = APIKeyHeader(name="X-API-KEY", auto_error=False)
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/auth/login", auto_error=False)


async def verify_api_key(
    request: Request,
    api_key: str = Security(api_key_header),
    token: str = Depends(oauth2_scheme),
):
    if request.url.path == "/health":
        return {"auth": "health", "role": "admin", "user_id": None, "email": None}

    # 1) JWT
    if token:
        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
            email = payload.get("sub")
            role = payload.get("role")
            user_id = payload.get("user_id")
            if email:
                return {"email": email, "role": role, "user_id": user_id, "auth": "jwt"}
        except JWTError:
            pass

    # 2) API KEY (legacy)
    if api_key and EXPECTED_API_KEY and api_key == EXPECTED_API_KEY:
        return {"auth": "api_key", "role": "admin", "user_id": None, "email": None}

    raise HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="No autorizado. Envie token JWT o X-API-KEY valido.",
        headers={"WWW-Authenticate": "Bearer"},
    )



### ARCHIVO: backoffice_api/app/auth_jwt.py ###
"""
JWT Authentication para Backoffice Login.
Archivo separado de auth.py (que maneja API KEY).
"""

import os
from datetime import datetime, timedelta
from typing import Optional

from jose import JWTError, jwt
import bcrypt
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from dotenv import load_dotenv

load_dotenv()

SECRET_KEY = os.getenv("SECRET_KEY")
if not SECRET_KEY:
    raise RuntimeError("FALTA SECRET_KEY en variables de entorno")
ALGORITHM = os.getenv("ALGORITHM", "HS256")
ACCESS_TOKEN_EXPIRE_MINUTES = int(os.getenv("ACCESS_TOKEN_EXPIRE_MINUTES", "480"))

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/auth/login")


def verify_password(plain_password: str, hashed_password: str) -> bool:
    return bcrypt.checkpw(
        plain_password.encode("utf-8"),
        hashed_password.encode("utf-8"),
    )


def get_password_hash(password: str) -> str:
    return bcrypt.hashpw(
        password.encode("utf-8"),
        bcrypt.gensalt(),
    ).decode("utf-8")


def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    to_encode = data.copy()
    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES))
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)


def get_current_user(token: str = Depends(oauth2_scheme)) -> dict:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Token invalido o expirado",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        email: str = payload.get("sub")
        role: str = payload.get("role")
        if email is None:
            raise credentials_exception
        return {"email": email, "role": role}
    except JWTError:
        raise credentials_exception



### ARCHIVO: backoffice_api/app/routers/diagnostics.py ###
"""Router: Diagnósticos y Health checks"""

import os
from fastapi import APIRouter, Depends
from ..db import fetch_one
from ..auth import verify_api_key

router = APIRouter(tags=["diagnostics"])


@router.get("/health")
def health():
    return {"ok": True, "service": "backoffice-api", "version": "0.6.0"}


@router.get("/diag/env")
def diag_env(api_key: str = Depends(verify_api_key)):
    return {
        "ok": True,
        "has_DATABASE_URL_RO": bool(os.getenv("DATABASE_URL_RO")),
        "has_DATABASE_URL_RW": bool(os.getenv("DATABASE_URL_RW")),
        "has_BACKOFFICE_API_KEY": bool(os.getenv("BACKOFFICE_API_KEY")),
    }


@router.get("/diag/db-users")
def diag_db_users(api_key: str = Depends(verify_api_key)):
    ro = fetch_one("SELECT current_user AS u", ())
    rw = fetch_one("SELECT current_user AS u", (), rw=True)
    return {"ok": True, "ro_user": ro["u"] if ro else None, "rw_user": rw["u"] if rw else None}


@router.get("/diag/db-roles")
def diag_db_roles(api_key: str = Depends(verify_api_key)):
    ro = fetch_one("SELECT current_user AS u", (), rw=False)
    rw = fetch_one("SELECT current_user AS u", (), rw=True)
    return {"ro_user": ro["u"] if ro else None, "rw_user": rw["u"] if rw else None}


@router.get("/version2")
def version2():
    return {"ok": True, "marker": "refactored_routers", "ts": "2026-02-11"}


@router.get("/gitsha")
def gitsha():
    return {
        "ok": True,
        "railway_commit": os.getenv("RAILWAY_GIT_COMMIT_SHA") or os.getenv("RAILWAY_GIT_COMMIT") or "unknown",
    }



### ARCHIVO: backoffice_api/app/routers/auth.py ###
"""
Router de autenticacion para Backoffice.
Endpoint: POST /auth/login
Permite login de admin y operator.
"""

from fastapi import APIRouter, HTTPException, status
from pydantic import BaseModel
from datetime import timedelta

from ..auth_jwt import (
    verify_password,
    create_access_token,
    ACCESS_TOKEN_EXPIRE_MINUTES,
)
from ..db import fetch_one

router = APIRouter(prefix="/auth", tags=["Auth"])


class LoginRequest(BaseModel):
    email: str
    password: str


class LoginResponse(BaseModel):
    access_token: str
    token_type: str
    role: str
    full_name: str
    user_id: int


@router.post("/login", response_model=LoginResponse)
def login(data: LoginRequest):
    user = fetch_one(
        """
        SELECT id, email, hashed_password, role, is_active, full_name, alias
        FROM users
        WHERE email = %s
        LIMIT 1
        """,
        (data.email,),
    )

    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Email o password incorrectos",
        )

    if user["role"] not in ("admin", "ADMIN", "operator"):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Acceso no permitido para este rol",
        )

    if not user["is_active"]:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Cuenta desactivada",
        )

    if not user["hashed_password"]:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Usuario sin password configurado",
        )

    if not verify_password(data.password, user["hashed_password"]):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Email o password incorrectos",
        )

    token = create_access_token(
        data={
            "sub": user["email"],
            "role": user["role"],
            "user_id": user["id"],
        },
        expires_delta=timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES),
    )

    display_name = user["full_name"] or user["alias"] or "Usuario"

    return LoginResponse(
        access_token=token,
        token_type="bearer",
        role=user["role"],
        full_name=display_name,
        user_id=user["id"],
    )



### ARCHIVO: backoffice_api/app/main.py ###
""" Sendmax Backoffice API Version con JWT Auth + Roles """

import os
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

from .routers import diagnostics, metrics, orders, origin_wallets, settings, alerts, corrections, auth, users

app = FastAPI(title="Sendmax Backoffice API", version="0.8.0")

# CORS Origins desde variable de entorno
ALLOWED_ORIGINS = os.getenv(
    "ALLOWED_ORIGINS",
    "http://localhost:3000,http://127.0.0.1:3000,https://sendmax-web-production.up.railway.app"
).split(",")

app.add_middleware(
    CORSMiddleware,
    allow_origins=ALLOWED_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Routers
app.include_router(auth.router)
app.include_router(users.router)
app.include_router(diagnostics.router)
app.include_router(metrics.router)
app.include_router(orders.router)
app.include_router(origin_wallets.router)
app.include_router(settings.router)
app.include_router(alerts.router)
app.include_router(corrections.router)


@app.get("/health")
def health():
    return {"status": "ok"}



### ARCHIVO: src/db/repositories/users_repo.py ###
"""
Repositorio de usuarios.

Aquí concentramos todas las consultas SQL sobre la tabla users.
"""

from __future__ import annotations
from src.db.connection import get_conn

from dataclasses import dataclass



@dataclass(frozen=True)
class User:
    id: int
    telegram_user_id: int
    alias: str
    role: str
    is_active: bool
    sponsor_id: int | None


@dataclass(frozen=True)
class UserKYC:
    id: int
    telegram_user_id: int
    alias: str
    role: str
    is_active: bool
    sponsor_id: int | None

    full_name: str | None
    phone: str | None
    address_short: str | None

    payout_country: str | None
    payout_method_text: str | None

    kyc_doc_file_id: str | None
    kyc_selfie_file_id: str | None
    kyc_status: str
    kyc_submitted_at: object | None
    kyc_reviewed_at: object | None
    kyc_review_reason: str | None

    email: str | None
    hashed_password: str | None


def get_user_by_telegram_id(telegram_user_id: int) -> User | None:
    sql = """
        SELECT id, telegram_user_id, alias, role, is_active, sponsor_id
        FROM users
        WHERE telegram_user_id = %s
        LIMIT 1;
    """
    with get_conn() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, (telegram_user_id,))
            row = cur.fetchone()
            return User(*row) if row else None


def get_user_by_alias(alias: str) -> User | None:
    sql = """
        SELECT id, telegram_user_id, alias, role, is_active, sponsor_id
        FROM users
        WHERE alias = %s
        LIMIT 1;
    """
    with get_conn() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, (alias,))
            row = cur.fetchone()
            return User(*row) if row else None


def get_telegram_id_by_user_id(user_id: int) -> int | None:
    sql = "SELECT telegram_user_id FROM users WHERE id = %s LIMIT 1;"
    with get_conn() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, (user_id,))
            row = cur.fetchone()
            return int(row[0]) if row else None


def create_user(
    telegram_user_id: int,
    alias: str,
    sponsor_id: int | None,
    role: str = "operator",
) -> User:
    sql = """
        INSERT INTO users (telegram_user_id, alias, sponsor_id, role)
        VALUES (%s, %s, %s, %s)
        RETURNING id, telegram_user_id, alias, role, is_active, sponsor_id;
    """
    with get_conn() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, (telegram_user_id, alias, sponsor_id, role))
            row = cur.fetchone()
            conn.commit()
            return User(*row)


def check_email_exists(email: str) -> bool:
    """Verifica si un email ya esta registrado (case-insensitive)."""
    sql = "SELECT 1 FROM users WHERE LOWER(email) = LOWER(%s) LIMIT 1;"
    with get_conn() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, (email,))
            return cur.fetchone() is not None


def get_user_kyc_by_telegram_id(telegram_user_id: int) -> UserKYC | None:
    sql = """
        SELECT
            id, telegram_user_id, alias, role, is_active, sponsor_id,
            full_name, phone, address_short,
            payout_country, payout_method_text,
            kyc_doc_file_id, kyc_selfie_file_id,
            kyc_status, kyc_submitted_at, kyc_reviewed_at, kyc_review_reason,
            email, hashed_password
        FROM users
        WHERE telegram_user_id = %s
        LIMIT 1;
    """
    with get_conn() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, (telegram_user_id,))
            row = cur.fetchone()
            return UserKYC(*row) if row else None


def submit_kyc(
    *,
    telegram_user_id: int,
    full_name: str,
    phone: str,
    address_short: str,
    payout_country: str,
    payout_method_text: str,
    kyc_doc_file_id: str,
    kyc_selfie_file_id: str,
    email: str,
    hashed_password: str,
) -> bool:
    """
    Guarda KYC completo y deja status=SUBMITTED. (Aprobación es manual por admin)
    """
    sql = """
        UPDATE users
        SET
            full_name=%s,
            phone=%s,
            address_short=%s,
            payout_country=%s,
            payout_method_text=%s,
            kyc_doc_file_id=%s,
            kyc_selfie_file_id=%s,
            email=%s,
            hashed_password=%s,
            kyc_status='SUBMITTED',
            kyc_submitted_at=now(),
            updated_at=now()
        WHERE telegram_user_id=%s;
    """
    with get_conn() as conn:
        with conn.cursor() as cur:
            cur.execute(
                sql,
                (
                    full_name, phone, address_short,
                    payout_country, payout_method_text,
                    kyc_doc_file_id, kyc_selfie_file_id,
                    email, hashed_password,
                    telegram_user_id,
                ),
            )
            ok = cur.rowcount > 0
            conn.commit()
            return ok


def set_kyc_status(
    *,
    user_id: int,
    new_status: str,
    reason: str | None = None,
) -> bool:
    """
    new_status: APPROVED / REJECTED / PENDING / SUBMITTED
    """
    sql = """
        UPDATE users
        SET
            kyc_status=%s,
            kyc_review_reason=%s,
            kyc_reviewed_at=now(),
            updated_at=now()
        WHERE id=%s;
    """
    with get_conn() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, (new_status, reason, user_id))
            ok = cur.rowcount > 0
            conn.commit()
            return ok


def set_payout_method(
    *,
    user_id: int,
    payout_country: str,
    payout_method_text: str,
) -> bool:
    sql = """
        UPDATE users
        SET payout_country=%s,
            payout_method_text=%s,
            updated_at=now()
        WHERE id=%s;
    """
    with get_conn() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, (payout_country, payout_method_text, user_id))
            ok = cur.rowcount > 0
            conn.commit()
            return ok


def get_payout_method(user_id: int) -> tuple[str | None, str | None]:
    sql = "SELECT payout_country, payout_method_text FROM users WHERE id=%s LIMIT 1;"
    with get_conn() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, (user_id,))
            row = cur.fetchone()
            if not row:
                return (None, None)
            return (row[0], row[1])


def update_kyc_draft(
    *,
    telegram_user_id: int,
    full_name: str | None = None,
    phone: str | None = None,
    address_short: str | None = None,
    payout_country: str | None = None,
    payout_method_text: str | None = None,
    kyc_doc_file_id: str | None = None,
    kyc_selfie_file_id: str | None = None,
    email: str | None = None,
    hashed_password: str | None = None,
) -> bool:
    """
    Guarda progreso parcial del KYC sin marcar SUBMITTED.
    Solo actualiza campos que vengan != None.
    """
    fields = []
    params = []

    def add(col: str, val):
        fields.append(f"{col}=%s")
        params.append(val)

    if full_name is not None:
        add("full_name", full_name)
    if phone is not None:
        add("phone", phone)
    if address_short is not None:
        add("address_short", address_short)
    if payout_country is not None:
        add("payout_country", payout_country)
    if payout_method_text is not None:
        add("payout_method_text", payout_method_text)
    if kyc_doc_file_id is not None:
        add("kyc_doc_file_id", kyc_doc_file_id)
    if kyc_selfie_file_id is not None:
        add("kyc_selfie_file_id", kyc_selfie_file_id)
    if email is not None:
        add("email", email)
    if hashed_password is not None:
        add("hashed_password", hashed_password)

    if not fields:
        return False

    sql = f"""
        UPDATE users
        SET {", ".join(fields)},
            updated_at=now()
        WHERE telegram_user_id=%s;
    """
    params.append(int(telegram_user_id))

    with get_conn() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, tuple(params))
            ok = cur.rowcount > 0
            conn.commit()
            return ok



### ARCHIVO: .gitignore ###
# Python
__pycache__/
*.py[cod]
*.pyd
*.pyo
*.pkl

# Virtualenv
.venv/

# Env / secrets
.env
backoffice_api/.env

# Logs
*.log

# Local dumps / temp
_audit_dump/
_backup_security/
_dump_for_review/
*.zip
.tmp_*
_show_*.py
_patch_*.py
_fix_*.py
_cleanup_*.py
_replace_*.py
_add_*.py

# OS
.DS_Store
Thumbs.db

openapi_snapshot.json

# Maintenance scripts y archivos temporales
scripts/maintenance/
temp_*.py
backoffice_web/temp_*.py

# Permitir .env.production del frontend
!backoffice_web/.env.production

# Archivos temporales movidos
_archivados/



### GREP: Quién importa auth/auth_jwt en el proyecto ###
alerts.py:6: from ..auth import verify_api_key
auth.py:11: from ..auth_jwt import (
corrections.py:6: from ..auth import verify_api_key
diagnostics.py:6: from ..auth import verify_api_key
metrics.py:12: from ..auth import verify_api_key
orders.py:9: from ..auth import verify_api_key
origin_wallets.py:7: from ..auth import verify_api_key
settings.py:8: from ..auth import verify_api_key
users.py:19: from ..auth import verify_api_key
users.py:20: from ..auth_jwt import get_password_hash
auth.py:5: from fastapi.security import APIKeyHeader, OAuth2PasswordBearer
auth_jwt.py:13: from fastapi.security import OAuth2PasswordBearer
main.py:7: from .routers import diagnostics, metrics, orders, origin_wallets, settings, alerts, corrections, auth, users


=== FIN ===
