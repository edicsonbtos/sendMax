from __future__ import annotations

"""
src/telegram_app/handlers/admin_withdrawals.py

Panel admin para gestionar retiros.

Seguridad/consistencia:
- Solo admin puede operar.
- Aprobar requiere comprobante (foto).
- Rechazar requiere motivo y revierte HOLD (eso ya lo hace WithdrawalsRepo.set_withdrawal_rejected).
- ConversationHandler usa CallbackQueryHandler -> per_message=False para evitar warning PTB y tracking correcto.

Notas UX:
- /withdrawals lista y ofrece botones.
- Botones "Aprobar" piden foto.
- Botones "Rechazar" piden texto.
- Botón "Volver" regresa a la lista.
"""

import logging
from decimal import Decimal

from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import (
    CallbackQueryHandler,
    CommandHandler,
    ConversationHandler,
    ContextTypes,
    MessageHandler,
    filters,
)

from src.config.settings import settings
from src.db.repositories.users_repo import get_telegram_id_by_user_id
from src.db.repositories.wallet_repo import get_conn as db_conn
from src.db.repositories.withdrawals_repo import WithdrawalsRepo

logger = logging.getLogger(__name__)

# --- Estados del flow admin ---
A_WAIT_PROOF, A_WAIT_REJECT_REASON = range(2)

# --- Callback data ---
CB_LIST = "awd_list"
CB_APPROVE = "awd_appr:"
CB_REJECT = "awd_rej:"
CB_BACK = "awd_back"


def _is_admin(update: Update) -> bool:
    """
    Admin gate simple: compara telegram user id con ADMIN_TELEGRAM_USER_ID.
    Si en tu app existe role=admin en users, podemos migrar a eso luego.
    """
    try:
        admin_id = int(settings.ADMIN_TELEGRAM_USER_ID)
    except Exception:
        return False
    user = update.effective_user
    return bool(user and user.id == admin_id)


def _list_keyboard(items: list) -> InlineKeyboardMarkup:
    rows: list[list[InlineKeyboardButton]] = []
    for w in items[:10]:
        rows.append(
            [
                InlineKeyboardButton(f"✅ Aprobar {w.id}", callback_data=f"{CB_APPROVE}{w.id}"),
                InlineKeyboardButton(f"❌ Rechazar {w.id}", callback_data=f"{CB_REJECT}{w.id}"),
            ]
        )
    rows.append([InlineKeyboardButton("🔄 Refrescar", callback_data=CB_LIST)])
    return InlineKeyboardMarkup(rows)


def build_admin_withdrawals_conversation_handler() -> ConversationHandler:
    """
    API pública que registra el bot.
    """
    return ConversationHandler(
        entry_points=[
            CommandHandler("withdrawals", admin_withdrawals_list),
            CallbackQueryHandler(admin_withdrawals_list, pattern=f"^({CB_LIST}|{CB_BACK})$"),
        ],
        states={
            A_WAIT_PROOF: [
                MessageHandler(filters.PHOTO, on_proof_photo),
                CallbackQueryHandler(admin_withdrawals_list, pattern=f"^{CB_BACK}$"),
            ],
            A_WAIT_REJECT_REASON: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, on_reject_reason),
                CallbackQueryHandler(admin_withdrawals_list, pattern=f"^{CB_BACK}$"),
            ],
        },
        fallbacks=[
            CallbackQueryHandler(admin_withdrawals_list, pattern=f"^{CB_BACK}$"),
            CommandHandler("cancel", admin_withdrawals_list),
        ],
        name="admin_withdrawals",
        persistent=False,
        per_chat=True,
        per_user=True,
        per_message=False,  # <- elimina warning PTB
    )


async def admin_withdrawals_list(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if not _is_admin(update):
        return ConversationHandler.END

    context.user_data.pop("admin_withdrawal_action", None)

    target = update.callback_query.message if update.callback_query else update.message
    if update.callback_query:
        await update.callback_query.answer()

    with db_conn() as conn:
        repo = WithdrawalsRepo(conn)
        items = repo.list_withdrawals_by_status("SOLICITADA", limit=20)

    if not items:
        await target.reply_text("✅ No hay retiros SOLICITADOS.")
        return ConversationHandler.END

    lines = ["💼 Retiros SOLICITADOS (últimos 20)\n"]
    for w in items:
        fiat_amount = (
            f"{Decimal(w.fiat_amount):.2f} {w.fiat}"
            if w.fiat_amount is not None and w.fiat
            else "N/A"
        )
        lines.append(
            f"ID {w.id} | user {w.user_id} | {Decimal(w.amount_usdt):.8f} USDT | {w.country} | {fiat_amount}"
        )

    await target.reply_text("\n".join(lines))
    await target.reply_text("Selecciona una acción:", reply_markup=_list_keyboard(items))
    return ConversationHandler.END


async def on_click_approve(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if not _is_admin(update):
        return ConversationHandler.END

    q = update.callback_query
    await q.answer()

    withdrawal_id = int(q.data.split(":", 1)[1])
    context.user_data["admin_withdrawal_action"] = {"id": withdrawal_id, "mode": "approve"}

    kb = InlineKeyboardMarkup([[InlineKeyboardButton("⬅️ Volver", callback_data=CB_BACK)]])
    await q.message.reply_text(
        f"Envía la foto del comprobante para el retiro ID {withdrawal_id}.",
        reply_markup=kb,
    )
    return A_WAIT_PROOF


async def on_proof_photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if not _is_admin(update):
        return ConversationHandler.END

    action = context.user_data.get("admin_withdrawal_action") or {}
    withdrawal_id = int(action.get("id") or 0)
    if not withdrawal_id:
        await update.message.reply_text("Sesión expirada. Usa /withdrawals.")
        return ConversationHandler.END

    proof_file_id = update.message.photo[-1].file_id

    with db_conn() as conn:
        wrepo = WithdrawalsRepo(conn)
        wd = wrepo.get_withdrawal_by_id(withdrawal_id)
        if not wd:
            await update.message.reply_text("No encontré ese retiro.")
            return ConversationHandler.END

        # Nota: al resolver NO movemos wallet balance aquí,
        # porque el HOLD ya debitó el saldo. Resolver solo marca estado + comprobante.
        wrepo.set_withdrawal_resolved(withdrawal_id, proof_file_id)
        conn.commit()

    tg_id = get_telegram_id_by_user_id(wd.user_id)
    if tg_id:
        await context.bot.send_message(chat_id=int(tg_id), text="✅ Retiro exitoso. Ya fue procesado.")
        await context.bot.send_photo(chat_id=int(tg_id), photo=proof_file_id, caption="Comprobante")

    await update.message.reply_text(f"✅ Retiro {withdrawal_id} marcado como RESUELTO.")
    context.user_data.pop("admin_withdrawal_action", None)
    return ConversationHandler.END


async def on_click_reject(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if not _is_admin(update):
        return ConversationHandler.END

    q = update.callback_query
    await q.answer()

    withdrawal_id = int(q.data.split(":", 1)[1])
    context.user_data["admin_withdrawal_action"] = {"id": withdrawal_id, "mode": "reject"}

    kb = InlineKeyboardMarkup([[InlineKeyboardButton("⬅️ Volver", callback_data=CB_BACK)]])
    await q.message.reply_text(
        f"Escribe el motivo de rechazo para el retiro ID {withdrawal_id}.",
        reply_markup=kb,
    )
    return A_WAIT_REJECT_REASON


async def on_reject_reason(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if not _is_admin(update):
        return ConversationHandler.END

    reason = (update.message.text or "").strip()
    if len(reason) < 3:
        await update.message.reply_text("Motivo muy corto. Intenta de nuevo.")
        return A_WAIT_REJECT_REASON

    action = context.user_data.get("admin_withdrawal_action") or {}
    withdrawal_id = int(action.get("id") or 0)
    if not withdrawal_id:
        await update.message.reply_text("Sesión expirada. Usa /withdrawals.")
        return ConversationHandler.END

    with db_conn() as conn:
        wrepo = WithdrawalsRepo(conn)
        wd = wrepo.get_withdrawal_by_id(withdrawal_id)
        if not wd:
            await update.message.reply_text("No encontré ese retiro.")
            return ConversationHandler.END

        # Rechazar revierte el HOLD (credit wallet + ledger reversal)
        wrepo.set_withdrawal_rejected(withdrawal_id, reason)
        conn.commit()

    tg_id = get_telegram_id_by_user_id(wd.user_id)
    if tg_id:
        await context.bot.send_message(chat_id=int(tg_id), text=f"❌ Tu retiro fue rechazado.\nMotivo: {reason}")

    await update.message.reply_text(f"❌ Retiro {withdrawal_id} RECHAZADO y saldo revertido.")
    context.user_data.pop("admin_withdrawal_action", None)
    return ConversationHandler.END


# IMPORTANTÍSIMO:
# Estos handlers de click deben existir y ser registrables si tu lista usa botones.
# Si tu bot registra estos callbacks por pattern en otro lado, mantenlos aquí igual.
admin_withdrawals_callbacks = [
    CallbackQueryHandler(on_click_approve, pattern=f"^{CB_APPROVE}"),
    CallbackQueryHandler(on_click_reject, pattern=f"^{CB_REJECT}"),
]

