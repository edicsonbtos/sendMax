from __future__ import annotations

from decimal import Decimal, InvalidOperation

from telegram import InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup, Update
from telegram.ext import (
    CallbackQueryHandler,
    CommandHandler,
    ConversationHandler,
    ContextTypes,
    MessageHandler,
    filters,
)

from src.config.settings import settings
from src.db.repositories import rates_repo
from src.db.repositories.users_repo import get_user_by_telegram_id
from src.db.repositories.wallet_repo import get_balance, get_conn as db_conn
from src.db.repositories.withdrawals_repo import WithdrawalsRepo


# -----------------
# Conversation states
# -----------------
W_COUNTRY, W_AMOUNT, W_DEST, W_CONFIRM = range(4)

# -----------------
# Callback constants
# -----------------
CB_COUNTRY = "wd_country:"
CB_CONFIRM = "wd_confirm"
CB_CANCEL = "wd_cancel"

# Admin action buttons (must match admin_withdrawals.py patterns)
CB_ADMIN_APPROVE = "wd_admin_appr:"
CB_ADMIN_REJECT = "wd_admin_rej:"

ACTIVE_COUNTRIES = ["USA", "CHILE", "PERU", "COLOMBIA", "VENEZUELA", "MEXICO", "ARGENTINA"]
MIN_WITHDRAW_USDT = Decimal("10")


# -----------------
# Small helpers
# -----------------
async def _safe_answer(q) -> None:
    try:
        await q.answer()
    except Exception:
        # "Query is too old..." / invalid id, etc.
        pass


def _home_keyboard() -> ReplyKeyboardMarkup:
    # Menú principal fijo (misma estructura que ui/keyboards.py)
    return ReplyKeyboardMarkup(
        [
            ["📈 Tasas", "💼 Billetera"],
            ["🚀 Nuevo envío"],
            ["📊 Resumen", "👥 Referidos"],
            ["🏦 Métodos de pago"],
        ],
        resize_keyboard=True,
        is_persistent=True,
    )


def _kb_cancel() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup([[InlineKeyboardButton("Cancelar", callback_data=CB_CANCEL)]])


def _kb_confirm_cancel() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(
        [
            [InlineKeyboardButton("✅ Confirmar", callback_data=CB_CONFIRM)],
            [InlineKeyboardButton("Cancelar", callback_data=CB_CANCEL)],
        ]
    )


def _kb_countries() -> InlineKeyboardMarkup:
    rows, row = [], []
    for c in ACTIVE_COUNTRIES:
        row.append(InlineKeyboardButton(c, callback_data=f"{CB_COUNTRY}{c}"))
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)
    rows.append([InlineKeyboardButton("Cancelar", callback_data=CB_CANCEL)])
    return InlineKeyboardMarkup(rows)


def _admin_request_keyboard(withdrawal_id: int) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(
        [[
            InlineKeyboardButton("✅ Aprobar", callback_data=f"{CB_ADMIN_APPROVE}{withdrawal_id}"),
            InlineKeyboardButton("❌ Rechazar", callback_data=f"{CB_ADMIN_REJECT}{withdrawal_id}"),
        ]]
    )


def _set_panel(context: ContextTypes.DEFAULT_TYPE, chat_id: int, message_id: int) -> None:
    context.user_data["withdraw_panel"] = {"chat_id": chat_id, "message_id": message_id}


def _get_panel(context: ContextTypes.DEFAULT_TYPE) -> tuple[int | None, int | None]:
    panel = context.user_data.get("withdraw_panel") or {}
    return panel.get("chat_id"), panel.get("message_id")


async def _edit_panel(
    update: Update,
    context: ContextTypes.DEFAULT_TYPE,
    text: str,
    reply_markup: InlineKeyboardMarkup | None = None,
) -> None:
    """
    Edita SIEMPRE el mismo mensaje del flow ("pantalla única").
    Si por alguna razón no existe (usuario lo borró), lo recrea.
    """
    chat_id, message_id = _get_panel(context)

    if chat_id and message_id:
        try:
            await context.bot.edit_message_text(
                chat_id=chat_id,
                message_id=message_id,
                text=text,
                reply_markup=reply_markup,
                disable_web_page_preview=True,
            )
            return
        except Exception:
            pass

    # fallback: recrear panel
    target_chat_id = chat_id or (update.effective_chat.id if update.effective_chat else None)
    if target_chat_id is None:
        return
    msg = await context.bot.send_message(chat_id=target_chat_id, text=text, reply_markup=reply_markup)
    _set_panel(context, msg.chat_id, msg.message_id)


def build_withdrawal_conversation_handler() -> ConversationHandler:
    """
    Entry points:
    - /withdraw
    - callback from wallet button: withdraw_start
    - legacy: wallet_withdraw
    """
    return ConversationHandler(
        entry_points=[
            CommandHandler("withdraw", start_withdrawal),
            CallbackQueryHandler(start_withdrawal, pattern=r"^(withdraw_start|wallet_withdraw)$"),
        ],
        states={
            W_COUNTRY: [
                CallbackQueryHandler(on_country_selected, pattern=f"^{CB_COUNTRY}"),
                CallbackQueryHandler(on_cancel_cb, pattern=f"^{CB_CANCEL}$"),
            ],
            W_AMOUNT: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, on_amount),
                CallbackQueryHandler(on_cancel_cb, pattern=f"^{CB_CANCEL}$"),
            ],
            W_DEST: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, on_dest_text),
                CallbackQueryHandler(on_cancel_cb, pattern=f"^{CB_CANCEL}$"),
            ],
            W_CONFIRM: [
                CallbackQueryHandler(on_confirm_or_cancel, pattern=f"^({CB_CONFIRM}|{CB_CANCEL})$"),
            ],
        },
        fallbacks=[
            CallbackQueryHandler(on_cancel_cb, pattern=f"^{CB_CANCEL}$"),
            CommandHandler("cancel", cancel_withdrawal),
        ],
        name="withdrawal_flow_user",
        persistent=False,
        per_chat=True,
        per_user=True,
        per_message=False,
    )


# -----------------
# Flow steps
# -----------------
async def start_withdrawal(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    # reset flow data but keep a single panel
    context.user_data.pop("withdrawal", None)

    if update.callback_query:
        q = update.callback_query
        await _safe_answer(q)
        _set_panel(context, q.message.chat_id, q.message.message_id)
    else:
        # Create a panel message to edit later
        msg = await update.message.reply_text("Cargando retiro…")
        _set_panel(context, msg.chat_id, msg.message_id)

    await _edit_panel(update, context, "¿En qué país quieres retirar?", reply_markup=_kb_countries())
    return W_COUNTRY


async def on_cancel_cb(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    q = update.callback_query
    await _safe_answer(q)
    context.user_data.pop("withdrawal", None)
    context.user_data.pop("withdraw_panel", None)
    await q.message.reply_text("Operación cancelada.", reply_markup=_home_keyboard())
    return ConversationHandler.END


async def on_country_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    q = update.callback_query
    await _safe_answer(q)

    country = q.data.split(":", 1)[1]

    result = rates_repo.get_latest_active_country_sell(country=country)
    if not result:
        context.user_data.pop("withdrawal", None)
        await _edit_panel(update, context, "No tengo tasa activa para ese país. Intenta más tarde.", reply_markup=_kb_cancel())
        return W_COUNTRY

    fiat, sell_price = result
    context.user_data["withdrawal"] = {"country": country, "fiat": fiat, "sell_price": str(sell_price)}

    await _edit_panel(
        update,
        context,
        f"País: {country}\n\n"
        f"Escribe el monto a retirar en USDT.\n"
        f"Mínimo: {MIN_WITHDRAW_USDT} USDT (ej: 50).",
        reply_markup=_kb_cancel(),
    )
    return W_AMOUNT


async def on_amount(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    # opcional: borrar el mensaje del usuario para mantener pantalla limpia
    try:
        await update.message.delete()
    except Exception:
        pass

    wd = context.user_data.get("withdrawal") or {}
    if not wd.get("country"):
        await _edit_panel(update, context, "Sesión expirada. Vuelve a intentar desde 💼 Billetera.", reply_markup=_kb_cancel())
        return W_COUNTRY

    txt = (update.message.text or "").strip().replace(",", ".")
    try:
        amount = Decimal(txt)
    except InvalidOperation:
        await _edit_panel(update, context, "Monto inválido. Ingresa un nuevo monto o cancela.", reply_markup=_kb_cancel())
        return W_AMOUNT

    if amount <= 0:
        await _edit_panel(update, context, "Monto inválido. Debe ser mayor a 0. Ingresa un nuevo monto o cancela.", reply_markup=_kb_cancel())
        return W_AMOUNT

    # CLAVE: NO salir ni reiniciar por < 10
    if amount < MIN_WITHDRAW_USDT:
        await _edit_panel(
            update,
            context,
            f"Monto inválido. El mínimo es {MIN_WITHDRAW_USDT} USDT.\n\nIngresa un nuevo monto o cancela.",
            reply_markup=_kb_cancel(),
        )
        return W_AMOUNT

    db_user = get_user_by_telegram_id(update.effective_user.id)
    if not db_user:
        await _edit_panel(update, context, "No estás registrado. Usa /start.", reply_markup=_kb_cancel())
        return W_AMOUNT

    balance = get_balance(db_user.id)
    if amount > balance:
        await _edit_panel(
            update,
            context,
            f"Saldo insuficiente. Tu balance es {balance:.8f} USDT.\n\nIngresa un monto menor o cancela.",
            reply_markup=_kb_cancel(),
        )
        return W_AMOUNT

    sell_price = Decimal(wd["sell_price"])
    fiat_amount = (amount * sell_price).quantize(Decimal("0.01"))

    wd["amount_usdt"] = str(amount)
    wd["fiat_amount"] = str(fiat_amount)
    context.user_data["withdrawal"] = wd

    await _edit_panel(update, context, "Escribe los datos de destino (cuenta/banco/nombre).", reply_markup=_kb_cancel())
    return W_DEST


async def on_dest_text(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    try:
        await update.message.delete()
    except Exception:
        pass

    dest_text = (update.message.text or "").strip()
    if len(dest_text) < 5:
        await _edit_panel(update, context, "Destino muy corto. Escribe un destino más claro o cancela.", reply_markup=_kb_cancel())
        return W_DEST

    wd = context.user_data.get("withdrawal") or {}
    if not wd.get("amount_usdt"):
        await _edit_panel(update, context, "Sesión expirada. Vuelve a intentar desde 💼 Billetera.", reply_markup=_kb_cancel())
        return W_COUNTRY

    wd["dest_text"] = dest_text
    context.user_data["withdrawal"] = wd

    amount = Decimal(wd["amount_usdt"])
    fiat_amount = Decimal(wd["fiat_amount"])

    await _edit_panel(
        update,
        context,
        "Confirma tu retiro:\n\n"
        f"• País: {wd['country']}\n"
        f"• Monto: {amount:.8f} USDT\n"
        f"• Estimado: {fiat_amount:.2f} {wd['fiat']}\n"
        f"• Destino: {dest_text}\n",
        reply_markup=_kb_confirm_cancel(),
    )
    return W_CONFIRM


async def on_confirm_or_cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    q = update.callback_query
    await _safe_answer(q)

    if q.data == CB_CANCEL:
        context.user_data.pop("withdrawal", None)
        context.user_data.pop("withdraw_panel", None)
        await q.message.reply_text("Operación cancelada.", reply_markup=_home_keyboard())
        return ConversationHandler.END

    wd = context.user_data.get("withdrawal") or {}
    if not wd:
        await q.message.reply_text("Sesión expirada. Intenta de nuevo.", reply_markup=_home_keyboard())
        return ConversationHandler.END

    db_user = get_user_by_telegram_id(q.from_user.id)
    if not db_user:
        context.user_data.pop("withdrawal", None)
        context.user_data.pop("withdraw_panel", None)
        await q.message.reply_text("No estás registrado. Usa /start.", reply_markup=_home_keyboard())
        return ConversationHandler.END

    amount = Decimal(wd["amount_usdt"])
    if amount < MIN_WITHDRAW_USDT:
        # seguridad extra: mantener en monto, NO reiniciar
        await _edit_panel(update, context, f"Monto inválido. El mínimo es {MIN_WITHDRAW_USDT} USDT.", reply_markup=_kb_cancel())
        return W_AMOUNT

    country = wd["country"]
    fiat = wd["fiat"]
    fiat_amount = Decimal(wd["fiat_amount"])
    dest_text = wd["dest_text"]

    with db_conn() as conn:
        repo = WithdrawalsRepo(conn)
        try:
            withdrawal_id = repo.create_withdrawal_request_fiat(
                user_id=db_user.id,
                amount_usdt=amount,
                country=country,
                fiat=fiat,
                fiat_amount=fiat_amount,
                dest_text=dest_text,
            )
            conn.commit()
        except ValueError as e:
            await _edit_panel(update, context, f"❌ {str(e)}", reply_markup=_kb_cancel())
            return W_AMOUNT

    # cerrar flow
    context.user_data.pop("withdrawal", None)
    context.user_data.pop("withdraw_panel", None)

    await q.message.reply_text("✅ Solicitud creada. Te avisaré cuando sea procesada.", reply_markup=_home_keyboard())

    # alerta admin
    admin_chat_id = int(settings.ADMIN_TELEGRAM_USER_ID)
    admin_text = (
        "💼 Retiro SOLICITADO\n\n"
        f"Operador: {db_user.alias}\n"
        f"País: {country}\n"
        f"Monto: {amount:.8f} USDT\n"
        f"Estimado: {fiat_amount:.2f} {fiat}\n"
        f"Destino: {dest_text}\n"
        f"ID: {withdrawal_id}"
    )
    await context.bot.send_message(chat_id=admin_chat_id, text=admin_text, reply_markup=_admin_request_keyboard(withdrawal_id))
    return ConversationHandler.END


async def cancel_withdrawal(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data.pop("withdrawal", None)
    context.user_data.pop("withdraw_panel", None)
    await update.message.reply_text("Operación cancelada.", reply_markup=_home_keyboard())
    return ConversationHandler.END
